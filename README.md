# n0stack

[![Build Status](https://travis-ci.org/n0stack/proto.svg?branch=master)](https://travis-ci.org/n0stack/proto)

## Motivation

現在のOpenstackやKubernetesは以下のような問題を抱えていると考えている。

- Openstackやkubernetesは汎用性を求めすぎてオプションの量がしんどい (k8sはまともだけど)
  - もちろん開発者が多く、いいプロダクトだと思うのですみわけをしていきたい
    - Openstackは構築コストが低い検証環境のIaaS基盤として
    - Kubernetesは...
- プロダクション環境は結局自社に合わせたインフラが必要になるが、たいていは完全に合致しないためある程度書き換えないといけない
  - 結局ソースコードを全部理解するような人が必要で、そこからいい感じに書き換えるか互換のあるものを作るというコストは結構高い
  - 設定を四苦八苦するよりもわかりやすくて短いソースを読んだほうが理解できるし、何なら自分で書いたほうがいい

以上を踏まえ我々は、 *最初から自分で最高に合致するものを書けばよい* という結論に至った。よって開発するにあたって以下のことを前提とする。

- コードは短く、シンプルに、汎用性の一切を排除
  - オプションも最小限に
- gRPCでインターフェイスはしっかり定義してやる
  - OSSの再利用性を確保するため
    - 例えばComputeの実装はそのまま使えるけどNetworkだけ機材が違うから書き換えたいなど
  - provisioning(リソースの仮想化)、middleware(SaaS)、application(アプリケーションの抽象化)、service(サービスの抽象化)など抽象化するレベルを分ける
- 我々が作るメインストリームはあくまでモデルケース
  - 変える必要があれば各自がフォークして良しなにやること

加えて、個人的に楽しいので可能な限り新しく面白い技術を採用していく。

## 抽象化のレベル

クラウド基盤を作成するにあたっての前提として、我々がやりたいことはサービスの提供・デプロイを自動化することである。よって、これまでサービスを提供するにあたって行ってきたことを綺麗にモデリングすれば自ずと正しく抽象化されると考えた。

### サービスを提供するために必要な作業

#### 十分に仮想化された場合 (VM)

1. リソースを確保 (VMやDockerで)
2. 依存パッケージのインストール (OSを含む)
3. インタープリター言語の場合、言語のインストール
4. 依存ライブラリのインストール
5. アプリケーションの配置
6. 設定 (環境変数や設定ファイル)
7. 実行
8. サービスに組み込み (LBなど)

#### 十分に仮想化された場合 (Docker)

1. Dockerfile
    - 依存パッケージのインストール (OSを含む)
    - インタープリター言語の場合、言語ランタイムのインストール
    - 依存ライブラリのインストール
7. 実行
    - 設定 (環境変数や設定ファイル)
    - リソースを確保 (VMやDockerで)
8. サービスに組み込み (LBなど)

#### ベアメタルの場合

1. ホストの起動
2. OSのインストール
3. ネットワークの疎通性確保
4. 依存パッケージのインストール (OSを含む)
3. インタープリター言語の場合、言語のインストール
4. 依存ライブラリのインストール
5. アプリケーションの配置
6. 設定 (環境変数や設定ファイル)
7. 実行
8. サービスに組み込み (LBなど)

#### 更新作業
##### ブルーグリーンデプロイ (immutable)

1. 新規のリソースを確保 (VMやDockerで)
2. 依存パッケージのインストール (OSを含む)
3. インタープリター言語の場合、言語のインストール
4. 依存ライブラリのインストール
5. アプリケーションの配置
6. 設定 (環境変数や設定ファイル)
7. 実行
8. サービスに組み込み (LBなど)
9. 古いものをサービスから退役

##### (mutable)

1. サービスから退役
2. 動的なリソースの変更 (ディスク増設など)
2. 依存パッケージの更新 (OSを含む)
3. インタープリター言語の場合、言語の更新
4. 依存ライブラリの更新
5. アプリケーションの更新
6. 設定 (環境変数や設定ファイル)
7. 実行
8. サービスに組み込み (LBなど)

#### 運用
##### 障害発生

1. 情報収集
    - メトリクス回収
    - SSHログイン
2. サービス復旧を第一目標に1次対応 (30分以内)
    - リソースの操作
        - VMの再起動
        - Volumeの拡張
3. 恒久的な2次対応

#### ネットワーク機器

1. 起動
2. IPの初期設定 (ここまで手作業)
3. サービスを提供するための初期設定
4. サービスを提供するための設定

### 作業の抽象化

作業を簡単にすると以下のようになる。

1. リソースの確保
2. プロビジョニング
4. アプリケーションの設定
5. アプリケーションのデプロイ
6. サービスに組み込み

よって考えられるリソースは以下のようになる。今後CPUなどのリソースとリソース志向のリソースが重複しているため、リソース志向のリソースをモデルと呼称する。

1. リソースの確保
    - resource: 仮想化されたリソース
        - cpu
        - memory
        - ip addresses
        - hw addr
        - networkid
4. プロビジョニング
    - provisioning: 初期設定、クラスタレベルの展開
        - network: ネットワーク
        - compute: VM
        - volume: 2次記憶領域
        - image: テンプレートイメージ
        - node: 物理ノード
5. アプリケーションの設定
    - configuration: 環境変数や設定ファイル、パッケージインストールなど
        - cloudinit: ?
        - ansible: ?
    - middleware: DBサービスなど
         - dhcp: computeかVMにタグをつける
         - rdb:
6. アプリケーションのデプロイ
    - application: アプリケーションの実行
        - snapshot: ?
        - pod: ?
    - deployment: スケールアウトなどアプリケーションの使い方によって定義
        - job
        - autoscale
        - simple
7. サービスに組み込み
    - service: LBやAPI ゲートウェイに組み込むなど
    - delivery: ブルーグリーンデプロイやカナリアデプロイなど

## build

```sh
docker build -t n0stack/build-proto .
docker run -it --rm  -v $PWD:/src:ro -v `go env GOPATH`/src:/dst n0stack/build-proto --go_out=plugins=grpc:/dst
```
